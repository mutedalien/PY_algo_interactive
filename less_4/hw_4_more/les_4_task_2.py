import cProfile
import math

# -----------------------------------------------------------------------------------------------------------
# алгоритм поиска простых чисел "Решето Эратосфена"
# -----------------------------------------------------------------------------------------------------------

# ТЕСТ через: cProfile.run('sieve(N)')
# 1    0.000    0.000    0.000    0.000 les_4_task_2.py:12(sieve) - 1
# 1    0.000    0.000    0.000    0.000 les_4_task_2.py:12(sieve) - 10
# 1    0.000    0.000    0.000    0.000 les_4_task_2.py:12(sieve) - 100
# 1    0.006    0.006    0.007    0.007 les_4_task_2.py:12(sieve) - 1000
# 1    0.108    0.108    0.116    0.116 les_4_task_2.py:12(sieve) - 10000
# 1    1.376    1.376    1.490    1.490 les_4_task_2.py:21(sieve) - 100000
# Оценочная (на основе времени выполнения программы) сложность алгоритма - O(N*log(N))

# ТЕСТ через: python -m timeit -n 1000 -s "import les_4_task_2" "les_4_task_2.sieve(N)"
# "les_4_task_2.sieve(1)   - 1000 loops, best of 5: 2.92 usec per loop
# "les_4_task_2.sieve(10)  - 1000 loops, best of 5: 18.3 usec per loop
# "les_4_task_2.sieve(100) - 1000 loops, best of 5: 391  usec per loop

def sieve(n):
    # формула по которой мы расчитываем оценочное значение N-го простого числа
    # проверено для N <= 1000
    z = int( 1.2 * math.log(n) * n + 3 )
    arr = [i for i in range(z)]
    arr[1] = 0
    cnt = 0
    for i in range(2, z):
        if arr[i] != 0:
            j = i * 2
            while j < z:
                arr[j] = 0
                j += i
        if arr[i] != 0:
            cnt += 1
            if cnt == n:
                return arr[i]


# -----------------------------------------------------------------------------------------------------------
# Алгоритм поиска простых чисел методом перебора
# -----------------------------------------------------------------------------------------------------------

# ТЕСТ через: cProfile.run('simple(N)')
# 1        0.000    0.000    0.000   0.000 les_4_task_2.py:38(is_simple) - 1
# 28       0.000    0.000    0.000   0.000 les_4_task_2.py:38(is_simple) - 10
# 540      0.002    0.000    0.002   0.000 les_4_task_2.py:38(is_simple) - 100
# 7918     0.318    0.000    0.318   0.000 les_4_task_2.py:38(is_simple) - 1000
# 104728   60.393   0.001   60.393   0.001 les_4_task_2.py:38(is_simple) - 10000
# Оценочная (на основе времени выполнения программы) сложность алгоритма - O(N^2)

# ТЕСТ через: python -m timeit -n 1000 -s "import les_4_task_2" "les_4_task_2.simple(N)"
# "les_4_task_2.simple(1)   - 1000 loops, best of 5: 2.18 usec per loop
# "les_4_task_2.simple(10)  - 1000 loops, best of 5: 29.9 usec per loop
# "les_4_task_2.simple(100) - 1000 loops, best of 5: 1.92 msec per loop



def simple(n):
    def is_simple(n):
        for i in range(2, n // 2 + 1):
            if n % i == 0:
                return False
        return True

    cnt = 0

    # формула по которой мы расчитываем оценочное значение N-го простого числа
    # проверено для N <= 1000
    z = int(1.2 * math.log(n) * n + 3)
    for i in range(2, z):
        if is_simple(i):
            cnt += 1
            if cnt == n:
                return i


# -----------------------------------------------------------------------------------------------------------
# Проверка работы алгоритмов
# -----------------------------------------------------------------------------------------------------------

def run_test():
    n = 500
    n2 = 100

    print(f"Решето Эратосфена, для {n} дает следующий результат: {sieve(n)}")
    print(f"Простой перебор,   для {n} дает следующий результат: {simple(n)}")

    is_true = True
    for i in range(2, n2):
        if sieve(i) != simple(i):
            is_true = False
            break
    if is_true:
        print("Оба алгоритма дают одинаковый результат")
    else:
        print("Внимание! Алгоритмы дали разный результат!")

run_test() # закомментируйте эту строку, когда проверяете программу через cProfile или timeit
# cProfile.run('sieve(100000)')
# cProfile.run('simple(1000)')
