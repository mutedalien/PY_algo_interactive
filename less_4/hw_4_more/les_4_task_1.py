# -----------------------------------------------------------------------------------------------------------
# 2.4. Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,…
# Количество элементов (n) вводится с клавиатуры.

# -----------------------------------------------------------------------------------------------------------
# эта задача, одна из немногих, где входные данные не генерируются случайно, а представляют собой число (N)
# -----------------------------------------------------------------------------------------------------------

import cProfile
import functools


# -----------------------------------------------------------------------------------------------------------

# ТЕСТ через: cProfile.run('algo_1(N)')
# 10/1     0.000    0.000    0.000    0.000 les_4_task_1.py:14(algo_1) (N = 10)
# 100/1    0.000    0.000    0.000    0.000 les_4_task_1.py:14(algo_1) (N = 100)
# 500/1    0.001    0.000    0.001    0.001 les_4_task_1.py:14(algo_1) (N = 500)
# При N = 1000 возникает ошибка переполнения стека

# ТЕСТ через: python -m timeit -n 1000 -s "import les_4_task_1" "les_4_task_1.algo_1(N)"
# "les_4_task_1.algo_1(10)"  - 1000 loops, best of 5: 7.31 usec per loop
# "les_4_task_1.algo_1(100)" - 1000 loops, best of 5: 105  usec per loop
# "les_4_task_1.algo_1(500)" - 1000 loops, best of 5: 838  usec per loop

# реализация №1 (рекурсивная, обычная)
def algo_1(n):
    if n == 1:
        return 1
    if n % 2 == 1:
        return algo_1(n - 1) + 1.0 / 2 ** (n - 1)
    else:
        return algo_1(n - 1) - 1.0 / 2 ** (n - 1)


# -----------------------------------------------------------------------------------------------------------

# ТЕСТ через: cProfile.run('algo_2(N)')
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:38(algo_2) (N = 10)
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:38(algo_2) (N = 100)
# 1    0.001    0.001    0.001    0.001 les_4_task_1.py:38(algo_2) (N = 500)
# 1    0.002    0.002    0.002    0.002 les_4_task_1.py:38(algo_2) (N = 1000)
# При N = 10000 возникает ошибка свазанная с вычислением 2^N

# ТЕСТ через: python -m timeit -n 1000 -s "import les_4_task_1" "les_4_task_1.algo_2(N)"
# "les_4_task_1.algo_2(10)"   - 1000 loops, best of 5: 6.42 usec per loop
# "les_4_task_1.algo_2(100)"  - 1000 loops, best of 5: 86.6 usec per loop
# "les_4_task_1.algo_2(500)"  - 1000 loops, best of 5: 711  usec per loop
# "les_4_task_1.algo_2(1000)" - 1000 loops, best of 5: 2.19 msec per loop

# реализация №1 (нерекурсивная, обычная)
def algo_2(n):
    answer = 0
    for i in range(1, n + 1):
        if i % 2 == 1:
            answer += 1.0 / 2 ** (i - 1)
        else:
            answer -= 1.0 / 2 ** (i - 1)
    return answer


# -----------------------------------------------------------------------------------------------------------

# ТЕСТ через: cProfile.run('algo_3(N)')
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:50(algo_3) (N = 10)
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:50(algo_3) (N = 100)
# 1    0.001    0.001    0.001    0.001 les_4_task_1.py:50(algo_3) (N = 500)
# 1    0.002    0.002    0.002    0.002 les_4_task_1.py:50(algo_3) (N = 1000)
# При N = 10000 возникает ошибка свазанная с вычислением 2^N

# ТЕСТ через: python -m timeit -n 1000 -s "import les_4_task_1" "les_4_task_1.algo_3(N)"
# "les_4_task_1.algo_3(10)"   - 1000 loops, best of 5: 182 nsec per loop
# "les_4_task_1.algo_3(100)"  - 1000 loops, best of 5: 180 nsec per loop
# "les_4_task_1.algo_3(500)"  - 1000 loops, best of 5: 189 nsec per loop
# "les_4_task_1.algo_3(1000)" - 1000 loops, best of 5: 181 nsec per loop

# Примечание: во время теста появилось оповещение (при N = 1000):
# The test results are likely unreliable. The worst time (2.4 usec)
# was more than four times slower than the best time (181 nsec).

# реализация №3 (неркурсивная, оптимизированная)
@functools.lru_cache()
def algo_3(n):
    answer = 0
    for i in range(1, n + 1):
        if i % 2 == 1:
            answer += 1.0 / 2 ** (i - 1)
        else:
            answer -= 1.0 / 2 ** (i - 1)
    return answer


# -----------------------------------------------------------------------------------------------------------

# ТЕСТ через: cProfile.run('algo_2(N)')
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:63(algo_4) (N = 10)
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:63(algo_4) (N = 100)
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:63(algo_4) (N = 500)
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:63(algo_4) (N = 1000)
# 1    0.177    0.177    0.177    0.177 les_4_task_1.py:63(algo_4) (N = 1млн)

# ТЕСТ через: python -m timeit -n 1000 -s "import les_4_task_1" "les_4_task_1.algo_4(N)"
# "les_4_task_1.algo_4(10)"   - 1000 loops, best of 5: 2.05 usec per loop
# "les_4_task_1.algo_4(100)"  - 1000 loops, best of 5: 14.4 usec per loop
# "les_4_task_1.algo_4(500)"  - 1000 loops, best of 5: 73.9 usec per loop
# "les_4_task_1.algo_4(1000)" - 1000 loops, best of 5: 153  usec per loop

# реализация №4 (неркурсивная, оптимизированная вручную)
def algo_4(n):
    answer = 0
    now = 1
    for i in range(n):
        answer += now
        now /= -2.0
    return answer


# -----------------------------------------------------------------------------------------------------------
# тест алгоритмов
def test(algo):
    ans = algo(100)
    if abs(ans - 2.0 / 3.0) < 1e-6:
        return "Пройден!"
    else:
        return "Не пройден :("
    return


def run_test(s):
    print("\nТЕСТ №1")
    print(f"algo_1 - результат, для s = {s}: {algo_1(s)}")
    print(f"algo_2 - результат, для s = {s}: {algo_2(s)}")
    print(f"algo_3 - результат, для s = {s}: {algo_3(s)}")
    print(f"algo_4 - результат, для s = {s}: {algo_4(s)}")

    print("\nТЕСТ №2")
    print(f"algo_1 - результат автоматического тестирования: {test(algo_1)}")
    print(f"algo_2 - результат автоматического тестирования: {test(algo_2)}")
    print(f"algo_3 - результат автоматического тестирования: {test(algo_3)}")
    print(f"algo_4 - результат автоматического тестирования: {test(algo_4)}")


run_test(6)  # закомментируйте эту строку, когда проверяете программу через cProfile или timeit
# cProfile.run('algo_2(10000)')

# -----------------------------------------------------------------------------------------------------------

# Выводы:
# 1. При исследовании алгоритмов с помощью timeit наивысшая производительность наблюдается у алгоритма algo_3
# 2. cProfile показывает наивысшую производительность у алгоритма algo_4
# 3. Единственный алгоритм, способный работать с N > 10000 - это algo_4
# 4. Наихудший результат по производительности показал рекурсивный алгоритм algo_1 (при этом N д.б. меньше 1000)
# 5. сложность алгоритмов на основании оценки timeint:
#    - algo_1() - O(N*log(N))
#    - algo_2() - O(N*log(N)) - где O(N) - вычислительная сложность цикла, O(log(N)) - сложность возведения в степень
#    - algo_3() - O(1) - возможно Python понля, что ответ 1/6
#    - algo_4() - O(N)
